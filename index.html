<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IA Ultra Avanzada con Correcci√≥n Autom√°tica</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header .badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 5px 15px;
            border-radius: 20px;
            margin: 5px;
            font-size: 0.9em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 30px;
        }

        .section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .input-group input,
        .input-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .input-group input:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .input-group textarea {
            resize: vertical;
            min-height: 100px;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
            margin-top: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
        }

        .btn-info {
            background: linear-gradient(135deg, #2196F3 0%, #0d8bf2 100%);
        }

        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .btn-delete {
            background: #f44336;
            color: white;
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
        }

        .btn-delete:hover {
            background: #d32f2f;
            transform: scale(1.05);
        }

        .response-box {
            background: white;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #667eea;
            min-height: 150px;
            margin-top: 15px;
            max-height: 500px;
            overflow-y: auto;
        }

        .training-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 4px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 15px;
        }

        .training-content {
            flex: 1;
        }

        .training-item strong {
            color: #667eea;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .stat-card .number {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-card .label {
            color: #666;
            margin-top: 5px;
        }

        .status {
            padding: 10px;
            border-radius: 8px;
            margin-top: 15px;
            text-align: center;
            font-weight: 600;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
        }

        .status.warning {
            background: #fff3cd;
            color: #856404;
        }

        .analysis {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            border-left: 4px solid #2196F3;
        }

        .analysis-item {
            margin: 5px 0;
            color: #0d47a1;
        }

        .match-score {
            display: inline-block;
            background: #4caf50;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .combined-badge {
            display: inline-block;
            background: #ff9800;
            color: white;
            padding: 3px 10px;
            border-radius: 15px;
            font-size: 0.85em;
            font-weight: bold;
            margin-left: 10px;
        }

        .source-list {
            background: #f0f4f8;
            padding: 12px;
            border-radius: 8px;
            margin-top: 12px;
            font-size: 0.9em;
        }

        .source-item {
            padding: 8px;
            margin: 5px 0;
            background: white;
            border-radius: 6px;
            border-left: 3px solid #667eea;
        }

        .source-weight {
            display: inline-block;
            background: #e3f2fd;
            color: #1976d2;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .auto-tags {
            background: #f0f8ff;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .auto-tags span {
            display: inline-block;
            background: #e1f5fe;
            padding: 3px 8px;
            border-radius: 12px;
            margin: 2px;
            font-size: 0.8em;
        }

        .correction-box {
            background: #fff3cd;
            border: 2px solid #ffc107;
            padding: 12px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .correction-box h4 {
            color: #856404;
            margin-bottom: 8px;
        }

        .correction-item {
            background: white;
            padding: 6px 10px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 3px solid #ff9800;
        }

        .correction-item .before {
            text-decoration: line-through;
            color: #d32f2f;
        }

        .correction-item .after {
            color: #388e3c;
            font-weight: bold;
        }

        .feedback-btns {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .feedback-btn {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: transform 0.2s;
        }

        .feedback-btn:hover {
            transform: scale(1.05);
        }

        .feedback-good {
            background: #4caf50;
            color: white;
        }

        .feedback-bad {
            background: #f44336;
            color: white;
        }

        #fileInput {
            display: none;
        }

        .generated-response {
            background: linear-gradient(135deg, #e8f5e9 0%, #f1f8e9 100%);
            padding: 18px;
            border-radius: 10px;
            margin: 12px 0;
            border-left: 4px solid #4caf50;
            line-height: 1.8;
            font-size: 1.05em;
        }

        .coherence-badge {
            display: inline-block;
            background: #9c27b0;
            color: white;
            padding: 3px 10px;
            border-radius: 15px;
            font-size: 0.85em;
            font-weight: bold;
            margin-left: 10px;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .stats {
                grid-template-columns: repeat(2, 1fr);
            }

            .btn-group {
                grid-template-columns: 1fr;
            }

            .training-item {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß† IA Ultra Avanzada</h1>
            <p>Con Correcci√≥n Ortogr√°fica y An√°lisis Vocal Autom√°tico</p>
            <div>
                <span class="badge">‚úçÔ∏è Auto-Correcci√≥n</span>
                <span class="badge">üîÄ IA Combinada</span>
                <span class="badge">üéµ An√°lisis Vocal</span>
                <span class="badge">üéØ Precisi√≥n Mejorada</span>
            </div>
        </div>

        <div class="main-content">
            <div class="section">
                <h2>üìö Entrenar IA</h2>
                <div class="input-group">
                    <label for="question">Pregunta / Entrada:</label>
                    <textarea id="question" placeholder="Escribe aqu√≠... (La IA corregir√° autom√°ticamente)"></textarea>
                </div>
                <div class="input-group">
                    <label for="answer">Respuesta / Salida:</label>
                    <textarea id="answer" placeholder="Escribe la respuesta... (Se corregir√° al guardar)"></textarea>
                </div>
                <div id="corrections" class="correction-box" style="display:none;"></div>
                <div id="autoTags" class="auto-tags" style="display:none;">
                    <strong>Palabras clave:</strong> <span id="tagsList"></span>
                </div>
                <button class="btn" onclick="trainAI()">‚úÖ Entrenar IA (con correcci√≥n)</button>
                <button class="btn btn-secondary" onclick="viewTraining()">Ver Entrenamiento</button>
                
                <div class="btn-group">
                    <button class="btn btn-success" onclick="downloadTraining()">üì• Descargar</button>
                    <button class="btn btn-info" onclick="document.getElementById('fileInput').click()">üì§ Cargar</button>
                </div>
                <input type="file" id="fileInput" accept=".json" onchange="loadTraining(event)">
                
                <button class="btn btn-danger" onclick="clearAllTraining()">üóëÔ∏è Borrar Todo</button>
                <div id="trainStatus"></div>
            </div>

            <div class="section">
                <h2>üí¨ Consultar IA</h2>
                <div class="input-group">
                    <label for="userQuestion">Pregunta:</label>
                    <textarea id="userQuestion" placeholder="Escribe tu pregunta... La IA generar√° respuestas inteligentes"></textarea>
                </div>
                <button class="btn" onclick="askAI()">üöÄ Consultar</button>
                <div class="response-box" id="aiResponse">
                    La IA analizar√° profundamente tu pregunta y generar√° una respuesta combinada con correcci√≥n autom√°tica...
                </div>
                <div id="feedbackSection"></div>
                <div id="analysis"></div>
            </div>

            <div class="section" style="grid-column: 1 / -1;">
                <h2>üìä Estad√≠sticas</h2>
                <div class="stats">
                    <div class="stat-card">
                        <div class="number" id="totalTraining">0</div>
                        <div class="label">Entrenamientos</div>
                    </div>
                    <div class="stat-card">
                        <div class="number" id="totalWords">0</div>
                        <div class="label">Palabras √önicas</div>
                    </div>
                    <div class="stat-card">
                        <div class="number" id="totalQuestions">0</div>
                        <div class="label">Consultas</div>
                    </div>
                    <div class="stat-card">
                        <div class="number" id="dbSize">0 KB</div>
                        <div class="label">Tama√±o BD</div>
                    </div>
                </div>
            </div>

            <div class="section" style="grid-column: 1 / -1;">
                <h2>üìù Base de Conocimiento</h2>
                <div id="trainingList"></div>
            </div>
        </div>
    </div>

    <script>
        let trainingData = [];
        let questionCount = 0;
        let conversationContext = [];
        let lastUsedSources = [];

        const synonyms = {
            'hola': ['saludos', 'buenas', 'hey', 'alo', 'que tal'],
            'adios': ['chao', 'hasta luego', 'nos vemos', 'bye'],
            'gracias': ['muchas gracias', 'agradecido', 'thanks'],
            'ayuda': ['ayudar', 'asistencia', 'soporte', 'auxilio'],
            'como': ['de que manera', 'de que forma'],
            'que': ['cual', 'cuales'],
            'hacer': ['realizar', 'ejecutar', 'crear'],
            'bueno': ['bien', 'excelente', 'genial', 'perfecto'],
            'malo': ['mal', 'pesimo', 'terrible'],
            'programar': ['programacion', 'codificar', 'codigo', 'desarrollar'],
            'javascript': ['js', 'ecmascript'],
            'python': ['py'],
            'aprender': ['estudiar', 'ensenar', 'educacion']
        };

        const spellingCorrections = {
            'q': 'que', 'xq': 'porque', 'pq': 'porque', 'xk': 'porque',
            'tb': 'tambi√©n', 'tmb': 'tambi√©n', 'bn': 'bien',
            'd': 'de', 'k': 'que', 'x': 'por', 'pa': 'para',
            'porfa': 'por favor', 'porfavor': 'por favor',
            'hola': 'hola', 'ola': 'hola',
            'aver': 'a ver', 'aber': 'a ver',
            'aslo': 'hazlo', 'ase': 'hace', 'ahy': 'ah√≠',
            'q': 'qu√©', 'komo': 'como', 'kien': 'quien',
            'xfa': 'por favor', 'porq': 'porque',
            'entiendes': 'entiendes', 'bn': 'bien',
            'bro': 'hermano', 'wey': 'amigo'
        };

        const accentCorrections = {
            'como': 'c√≥mo', 'que': 'qu√©', 'cual': 'cu√°l', 'donde': 'd√≥nde',
            'cuando': 'cu√°ndo', 'quien': 'qui√©n', 'cuanto': 'cu√°nto',
            'mas': 'm√°s', 'si': 's√≠', 'tu': 't√∫', 'mi': 'm√≠',
            'te': 't√©', 'el': '√©l', 'solo': 's√≥lo',
            'esta': 'est√°', 'estas': 'est√°s', 'este': 'este',
            'razon': 'raz√≥n', 'acion': 'aci√≥n', 'informacion': 'informaci√≥n',
            'codigo': 'c√≥digo', 'tambien': 'tambi√©n', 'ahi': 'ah√≠',
            'dia': 'd√≠a', 'despues': 'despu√©s', 'facil': 'f√°cil',
            'dificil': 'dif√≠cil', 'util': '√∫til', 'semantica': 'sem√°ntica'
        };

        function analyzeVowelPattern(text) {
            const vowels = ['a', 'e', 'i', 'o', 'u', '√°', '√©', '√≠', '√≥', '√∫'];
            const consonants = 'bcdfghjklmnpqrstvwxyz';
            
            const normalized = text.toLowerCase();
            let vocalPattern = '';
            let consonantPattern = '';
            let vocalCount = {};
            let consonantCount = {};
            
            for (let char of normalized) {
                if (vowels.includes(char)) {
                    vocalPattern += 'V';
                    vocalCount[char] = (vocalCount[char] || 0) + 1;
                } else if (consonants.includes(char)) {
                    consonantPattern += 'C';
                    consonantCount[char] = (consonantCount[char] || 0) + 1;
                }
            }
            
            const totalVowels = Object.values(vocalCount).reduce((a, b) => a + b, 0);
            const totalConsonants = Object.values(consonantCount).reduce((a, b) => a + b, 0);
            
            const vocalRatio = totalVowels / (totalVowels + totalConsonants || 1);
            
            const vocalSignature = Object.keys(vocalCount).sort().join('');
            const consonantSignature = Object.keys(consonantCount).sort().join('');
            
            return {
                vocalPattern,
                consonantPattern,
                vocalCount,
                consonantCount,
                totalVowels,
                totalConsonants,
                vocalRatio,
                vocalSignature,
                consonantSignature,
                fullSignature: vocalSignature + consonantSignature
            };
        }

        function generateVowelVariations(word) {
            const variations = [word];
            const vowelMap = {
                'a': ['a', '√°'], 'e': ['e', '√©'], 'i': ['i', '√≠'],
                'o': ['o', '√≥'], 'u': ['u', '√∫'],
                '√°': ['a', '√°'], '√©': ['e', '√©'], '√≠': ['i', '√≠'],
                '√≥': ['o', '√≥'], '√∫': ['u', '√∫']
            };
            
            for (let i = 0; i < word.length; i++) {
                const char = word[i].toLowerCase();
                if (vowelMap[char]) {
                    vowelMap[char].forEach(variant => {
                        if (variant !== char) {
                            const newWord = word.substring(0, i) + variant + word.substring(i + 1);
                            variations.push(newWord);
                        }
                    });
                }
            }
            
            return variations;
        }

        function compareVocalPatterns(pattern1, pattern2) {
            const p1 = analyzeVowelPattern(pattern1);
            const p2 = analyzeVowelPattern(pattern2);
            
            let score = 0;
            
            if (p1.vocalSignature === p2.vocalSignature) {
                score += 25;
            } else {
                const commonVowels = Object.keys(p1.vocalCount).filter(v => p2.vocalCount[v]);
                score += commonVowels.length * 5;
            }
            
            if (p1.consonantSignature === p2.consonantSignature) {
                score += 20;
            } else {
                const commonConsonants = Object.keys(p1.consonantCount).filter(c => p2.consonantCount[c]);
                score += commonConsonants.length * 3;
            }
            
            const ratioDiff = Math.abs(p1.vocalRatio - p2.vocalRatio);
            score += (1 - ratioDiff) * 15;
            
            const lengthRatio = Math.min(p1.vocalPattern.length, p2.vocalPattern.length) / 
                               Math.max(p1.vocalPattern.length, p2.vocalPattern.length);
            score += lengthRatio * 10;
            
            return score;
        }

        function saveToStorage() {
            try {
                const dataToSave = {
                    trainingData: trainingData,
                    questionCount: questionCount,
                    lastSaved: new Date().toISOString()
                };
                const data = {};
                data['aiTrainingData'] = JSON.stringify(dataToSave);
            } catch(e) {}
        }

        function loadFromStorage() {
            try {
                const data = {};
                const saved = data['aiTrainingData'];
                if (saved) {
                    const parsed = JSON.parse(saved);
                    trainingData = parsed.trainingData || [];
                    questionCount = parsed.questionCount || 0;
                    const statusDiv = document.getElementById('trainStatus');
                    statusDiv.innerHTML = `<div class="status success">‚úì ${trainingData.length} entrenamientos cargados</div>`;
                    setTimeout(() => { statusDiv.innerHTML = ''; }, 3000);
                }
            } catch(e) {}
        }

        function correctSpelling(text) {
            let corrected = text;
            const corrections = [];
            
            const words = text.split(/\s+/);
            
            words.forEach(word => {
                const cleanWord = word.toLowerCase().replace(/[.,!?;:]/g, '');
                
                if (spellingCorrections[cleanWord]) {
                    const replacement = spellingCorrections[cleanWord];
                    corrected = corrected.replace(new RegExp('\\b' + word + '\\b', 'gi'), replacement);
                    corrections.push({ before: word, after: replacement });
                }
            });
            
            return { text: corrected, corrections };
        }

        function addAccents(text) {
            let corrected = text;
            const corrections = [];
            
            const isQuestion = text.includes('?') || 
                              /^(como|que|cual|donde|cuando|quien|cuanto)/i.test(text);
            
            if (isQuestion) {
                Object.entries(accentCorrections).forEach(([without, with_]) => {
                    const regex = new RegExp('\\b' + without + '\\b', 'gi');
                    if (regex.test(corrected)) {
                        corrected = corrected.replace(regex, with_);
                        corrections.push({ before: without, after: with_ });
                    }
                });
            }
            
            return { text: corrected, corrections };
        }

        function addPunctuation(text) {
            let corrected = text.trim();
            const corrections = [];
            
            if (!/[.!?]$/.test(corrected)) {
                corrections.push({ before: 'sin punto final', after: 'con punto final' });
                corrected += '.';
            }
            
            if (corrected.length > 0 && corrected[0] !== corrected[0].toUpperCase()) {
                corrections.push({ before: 'min√∫scula inicial', after: 'may√∫scula inicial' });
                corrected = corrected.charAt(0).toUpperCase() + corrected.slice(1);
            }
            
            corrected = corrected.replace(/\.([a-z√°√©√≠√≥√∫√±])/gi, '. $1');
            corrected = corrected.replace(/,([a-z√°√©√≠√≥√∫√±])/gi, ', $1');
            
            corrected = corrected.replace(/\.\s+([a-z√°√©√≠√≥√∫√±])/g, (match, letter) => {
                return '. ' + letter.toUpperCase();
            });
            
            return { text: corrected, corrections };
        }

        function fullCorrection(text) {
            if (!text || text.trim() === '') return { text: '', corrections: [] };
            
            let allCorrections = [];
            
            const spelling = correctSpelling(text);
            let result = spelling.text;
            allCorrections = allCorrections.concat(spelling.corrections);
            
            const accents = addAccents(result);
            result = accents.text;
            allCorrections = allCorrections.concat(accents.corrections);
            
            const punctuation = addPunctuation(result);
            result = punctuation.text;
            allCorrections = allCorrections.concat(punctuation.corrections);
            
            return { text: result, corrections: allCorrections };
        }

        function showCorrections(corrections) {
            const corrDiv = document.getElementById('corrections');
            
            if (corrections.length === 0) {
                corrDiv.style.display = 'none';
                return;
            }
            
            let html = '<h4>‚úçÔ∏è Correcciones aplicadas:</h4>';
            corrections.forEach(corr => {
                html += `
                    <div class="correction-item">
                        <span class="before">${corr.before}</span> ‚Üí 
                        <span class="after">${corr.after}</span>
                    </div>
                `;
            });
            
            corrDiv.innerHTML = html;
            corrDiv.style.display = 'block';
        }

        function normalizeText(text) {
            return text.toLowerCase()
                .normalize("NFD")
                .replace(/[\u0300-\u036f]/g, "")
                .replace(/[^\w\s]/g, " ")
                .replace(/\s+/g, " ")
                .trim();
        }

        function stem(word) {
            const suffixes = ['ando', 'iendo', 'mente', 'aci√≥n', 'ador', 'ante', 'ancia', 'encia', 
                            'ible', 'able', 'ismo', 'ista', 'oso', 'osa', 'ivo', 'iva',
                            'ar', 'er', 'ir', 'ado', 'ido', 'es', 'as', 'os', 's'];
            
            for (let suffix of suffixes) {
                if (word.length > suffix.length + 3 && word.endsWith(suffix)) {
                    return word.slice(0, -suffix.length);
                }
            }
            return word;
        }

        function tokenize(text) {
            const normalized = normalizeText(text);
            const words = normalized.split(/\s+/).filter(w => w.length > 0);
            const stems = words.map(w => stem(w));
            
            const bigrams = [];
            const trigrams = [];
            for (let i = 0; i < words.length - 1; i++) {
                bigrams.push(words[i] + ' ' + words[i + 1]);
                if (i < words.length - 2) {
                    trigrams.push(words[i] + ' ' + words[i + 1] + ' ' + words[i + 2]);
                }
            }
            
            const vocalPattern = analyzeVowelPattern(text);
            
            return { words, stems, normalized, bigrams, trigrams, vocalPattern };
        }

        function extractKeywords(text) {
            const { words } = tokenize(text);
            
            const commonWords = new Set([
                'que', 'qu√©', 'como', 'c√≥mo', 'para', 'por', 'con', 'de', 'en', 'la', 'el', 'los', 'las',
                'un', 'una', 'unos', 'unas', 'y', 'o', 'pero', 'si', 'no', 'es', 'son', 'soy', 'eres',
                'esta', 'este', 'estos', 'estas', 'al', 'del', 'lo', 'le', 'se', 'te', 'me', 'nos', 'os',
                'su', 'sus', 'mi', 'mis', 'tu', 'tus', 'a', 'ante', 'bajo', 'desde', 'entre', 'hacia',
                'hasta', 'seg√∫n', 'sin', 'sobre', 'tras', 'ser', 'estar', 'hay', 'tener'
            ]);
            
            const keywords = words.filter(word => word.length > 2 && !commonWords.has(word));
            
            const expandedKeywords = new Set(keywords);
            keywords.forEach(keyword => {
                if (synonyms[keyword]) {
                    synonyms[keyword].forEach(syn => expandedKeywords.add(syn));
                }
                Object.entries(synonyms).forEach(([key, syns]) => {
                    if (syns.includes(keyword)) {
                        expandedKeywords.add(key);
                    }
                });
                
                const variations = generateVowelVariations(keyword);
                variations.forEach(v => expandedKeywords.add(v));
            });
            
            return [...expandedKeywords];
        }

        function levenshtein(str1, str2) {
            const len1 = str1.length;
            const len2 = str2.length;
            const matrix = Array(len1 + 1).fill(null).map(() => Array(len2 + 1).fill(0));

            for (let i = 0; i <= len1; i++) matrix[i][0] = i;
            for (let j = 0; j <= len2; j++) matrix[0][j] = j;

            for (let i = 1; i <= len1; i++) {
                for (let j = 1; j <= len2; j++) {
                    const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j] + 1,
                        matrix[i][j - 1] + 1,
                        matrix[i - 1][j - 1] + cost
                    );
                }
            }

            const maxLen = Math.max(len1, len2);
            return maxLen === 0 ? 1 : 1 - (matrix[len1][len2] / maxLen);
        }

        function calculateSimilarity(text1, text2) {
            const tokens1 = tokenize(text1);
            const tokens2 = tokenize(text2);
            
            const set1 = new Set(tokens1.words);
            const set2 = new Set(tokens2.words);
            const intersection = new Set([...set1].filter(x => set2.has(x)));
            const union = new Set([...set1, ...set2]);
            const jaccard = union.size === 0 ? 0 : intersection.size / union.size;
            
            const levSim = levenshtein(tokens1.normalized, tokens2.normalized);
            
            const stemSet1 = new Set(tokens1.stems);
            const stemSet2 = new Set(tokens2.stems);
            const stemIntersection = new Set([...stemSet1].filter(x => stemSet2.has(x)));
            const stemUnion = new Set([...stemSet1, ...stemSet2]);
            const stemSim = stemUnion.size === 0 ? 0 : stemIntersection.size / stemUnion.size;
            
            const bigramSet1 = new Set(tokens1.bigrams);
            const bigramSet2 = new Set(tokens2.bigrams);
            const bigramIntersection = new Set([...bigramSet1].filter(x => bigramSet2.has(x)));
            const bigramUnion = new Set([...bigramSet1, ...bigramSet2]);
            const bigramSim = bigramUnion.size === 0 ? 0 : bigramIntersection.size / bigramUnion.size;
            
            let containsSim = 0;
            if (tokens1.normalized.includes(tokens2.normalized) || tokens2.normalized.includes(tokens1.normalized)) {
                const shorter = Math.min(tokens1.normalized.length, tokens2.normalized.length);
                const longer = Math.max(tokens1.normalized.length, tokens2.normalized.length);
                containsSim = shorter / longer;
            }
            
            const vocalSim = compareVocalPatterns(text1, text2) / 100;
            
            return (jaccard * 0.20 + levSim * 0.20 + stemSim * 0.15 + bigramSim * 0.15 + containsSim * 0.10 + vocalSim * 0.20) * 100;
        }

        function calculateCoherence(sentence1, sentence2) {
            const similarity = calculateSimilarity(sentence1, sentence2);
            
            const connectors = ['adem√°s', 'tambi√©n', 'por lo tanto', 'sin embargo', 'pero', 'y', 'asimismo'];
            let hasConnector = connectors.some(conn => sentence2.toLowerCase().includes(conn));
            
            const words1 = new Set(tokenize(sentence1).words);
            const words2 = new Set(tokenize(sentence2).words);
            const commonWords = [...words1].filter(w => words2.has(w)).length;
            
            if (similarity > 90) return 20;
            
            let coherence = 50;
            coherence += (similarity * 0.3);
            coherence += (hasConnector ? 15 : 0);
            coherence += (commonWords * 5);
            
            return Math.min(coherence, 100);
        }

        function findMatches(userInput) {
            const matches = [];
            const userTokens = tokenize(userInput);
            const userKeywords = extractKeywords(userInput);
            
            trainingData.forEach((item, index) => {
                let score = 0;
                const details = [];
                
                const qSimilarity = calculateSimilarity(userInput, item.question);
                score += qSimilarity * 0.55;
                if (qSimilarity > 5) details.push(`Pregunta: ${qSimilarity.toFixed(0)}%`);
                
                const aSimilarity = calculateSimilarity(userInput, item.answer);
                score += aSimilarity * 0.15;
                if (aSimilarity > 5) details.push(`Respuesta: ${aSimilarity.toFixed(0)}%`);
                
                const vocalScore = compareVocalPatterns(userInput, item.question);
                score += vocalScore * 0.3;
                if (vocalScore > 15) details.push(`Patr√≥n Vocal: ${vocalScore.toFixed(0)}%`);
                
                const keywordMatches = [];
                userKeywords.forEach(userKw => {
                    item.keywords.forEach(itemKw => {
                        if (userKw === itemKw || 
                            (synonyms[userKw] && synonyms[userKw].includes(itemKw)) ||
                            (synonyms[itemKw] && synonyms[itemKw].includes(userKw))) {
                            keywordMatches.push(itemKw);
                        }
                    });
                });
                
                if (keywordMatches.length > 0) {
                    score += keywordMatches.length * 10;
                    details.push(`Keywords: ${keywordMatches.length}`);
                }
                
                const bigramMatches = item.questionBigrams.filter(bg => userTokens.bigrams.includes(bg));
                if (bigramMatches.length > 0) {
                    score += bigramMatches.length * 15;
                    details.push(`Bigramas: ${bigramMatches.length}`);
                }
                
                const trigramMatches = item.questionTrigrams.filter(tg => userTokens.trigrams.includes(tg));
                if (trigramMatches.length > 0) {
                    score += trigramMatches.length * 20;
                    details.push(`Trigramas: ${trigramMatches.length}`);
                }
                
                const stemMatches = item.questionStems.filter(stem => userTokens.stems.includes(stem));
                if (stemMatches.length > 0) {
                    score += stemMatches.length * 8;
                }
                
                if (item.successCount > 0) {
                    const successRate = item.successCount / (item.successCount + item.failCount || 1);
                    score += successRate * 12;
                    if (successRate > 0.5) details.push(`√âxito: ${(successRate * 100).toFixed(0)}%`);
                }
                
                if (conversationContext.length > 0) {
                    conversationContext.forEach(ctx => {
                        const ctxSim = calculateSimilarity(ctx, item.question);
                        if (ctxSim > 30) {
                            score += 15;
                            details.push('Contexto+');
                        }
                    });
                }
                
                if (score > 0) {
                    matches.push({ item, index, score: Math.min(score, 100), details });
                }
            });
            
            matches.sort((a, b) => b.score - a.score);
            return matches;
        }

        function generateCombinedResponse(userInput, matches) {
            if (matches.length === 0) return null;
            
            const topMatches = matches.slice(0, 6).filter(m => m.score > 18);
            
            if (topMatches.length === 0) return null;
            
            if (topMatches.length === 1 && topMatches[0].score > 75) {
                const corrected = fullCorrection(topMatches[0].item.answer);
                return {
                    response: corrected.text,
                    combined: false,
                    sources: [topMatches[0]],
                    confidence: topMatches[0].score,
                    coherence: 100
                };
            }
            
            const weightedSources = topMatches.map(match => {
                const successRate = match.item.successCount / 
                    (match.item.successCount + match.item.failCount || 1);
                const weight = (match.score * 0.65) + (successRate * 100 * 0.35);
                
                return { ...match, weight, successRate };
            });
            
            weightedSources.sort((a, b) => b.weight - a.weight);
            
            const sentences = [];
            weightedSources.forEach(source => {
                const answerSentences = source.item.answer
                    .split(/[.!?]+/)
                    .map(s => s.trim())
                    .filter(s => s.length > 15);
                
                answerSentences.forEach(sentence => {
                    const relevance = calculateSimilarity(userInput, sentence);
                    
                    sentences.push({
                        text: sentence,
                        weight: source.weight + (relevance * 0.25),
                        source: source,
                        relevance: relevance
                    });
                });
            });
            
            const uniqueSentences = [];
            sentences.forEach(sent => {
                const isDuplicate = uniqueSentences.some(unique => 
                    calculateSimilarity(sent.text, unique.text) > 75
                );
                if (!isDuplicate && sent.text.length > 10) {
                    uniqueSentences.push(sent);
                }
            });
            
            uniqueSentences.sort((a, b) => b.weight - a.weight);
            
            const selectedSentences = [uniqueSentences[0]];
            let totalCoherence = 100;
            let coherenceCount = 1;
            
            for (let i = 1; i < Math.min(uniqueSentences.length, 5); i++) {
                const candidate = uniqueSentences[i];
                const lastSelected = selectedSentences[selectedSentences.length - 1];
                
                const coherence = calculateCoherence(lastSelected.text, candidate.text);
                
                if (coherence > 40 || selectedSentences.length < 2) {
                    selectedSentences.push(candidate);
                    totalCoherence += coherence;
                    coherenceCount++;
                }
                
                if (selectedSentences.length >= 4) break;
            }
            
            let combinedResponse = '';
            selectedSentences.forEach((sent, idx) => {
                if (idx === 0) {
                    combinedResponse += sent.text;
                } else {
                    const needsConnector = !sent.text.toLowerCase().startsWith('adem√°s') &&
                                          !sent.text.toLowerCase().startsWith('tambi√©n') &&
                                          !sent.text.toLowerCase().startsWith('por');
                    
                    if (needsConnector && Math.random() > 0.5) {
                        const connectors = ['. Adem√°s, ', '. Tambi√©n, ', '. Por otro lado, ', '. Asimismo, '];
                        combinedResponse += connectors[Math.floor(Math.random() * connectors.length)] + 
                                          sent.text.charAt(0).toLowerCase() + sent.text.slice(1);
                    } else {
                        combinedResponse += '. ' + sent.text;
                    }
                }
            });
            
            const finalCorrected = fullCorrection(combinedResponse);
            
            const totalWeight = weightedSources.reduce((sum, s) => sum + s.weight, 0);
            const avgConfidence = Math.min(totalWeight / weightedSources.length, 100);
            const avgCoherence = totalCoherence / coherenceCount;
            
            return {
                response: finalCorrected.text,
                combined: topMatches.length > 1,
                sources: weightedSources.slice(0, selectedSentences.length),
                confidence: avgConfidence,
                coherence: avgCoherence
            };
        }

        function trainAI() {
            const question = document.getElementById('question').value.trim();
            const answer = document.getElementById('answer').value.trim();
            const statusDiv = document.getElementById('trainStatus');

            if (!question || !answer) {
                statusDiv.innerHTML = '<div class="status error">Completa ambos campos</div>';
                return;
            }

            const qCorrected = fullCorrection(question);
            const aCorrected = fullCorrection(answer);
            
            const allCorrections = [...qCorrected.corrections, ...aCorrected.corrections];
            showCorrections(allCorrections);
            
            const correctedQuestion = qCorrected.text;
            const correctedAnswer = aCorrected.text;

            const { words: qWords, stems: qStems, bigrams: qBigrams, trigrams: qTrigrams, vocalPattern: qVocal } = tokenize(correctedQuestion);
            const { words: aWords, stems: aStems, bigrams: aBigrams, trigrams: aTrigrams, vocalPattern: aVocal } = tokenize(correctedAnswer);
            const keywords = extractKeywords(correctedQuestion + ' ' + correctedAnswer);
            
            trainingData.push({
                id: Date.now() + Math.random(),
                question: correctedQuestion,
                answer: correctedAnswer,
                questionNorm: normalizeText(correctedQuestion),
                answerNorm: normalizeText(correctedAnswer),
                questionWords: qWords,
                answerWords: aWords,
                questionStems: qStems,
                answerStems: aStems,
                questionBigrams: qBigrams,
                answerBigrams: aBigrams,
                questionTrigrams: qTrigrams,
                answerTrigrams: aTrigrams,
                questionVocalPattern: qVocal,
                answerVocalPattern: aVocal,
                keywords,
                successCount: 0,
                failCount: 0,
                useCount: 0,
                timestamp: new Date().toISOString()
            });

            saveToStorage();

            statusDiv.innerHTML = `<div class="status success">‚úì Entrenado${allCorrections.length > 0 ? ' y corregido' : ''}</div>`;
            document.getElementById('question').value = '';
            document.getElementById('answer').value = '';
            document.getElementById('autoTags').style.display = 'none';
            
            setTimeout(() => {
                document.getElementById('corrections').style.display = 'none';
            }, 5000);
            
            updateStats();
            viewTraining();
        }

        function deleteTraining(id) {
            if (!confirm('¬øEliminar?')) return;
            
            trainingData = trainingData.filter(item => item.id !== id);
            saveToStorage();
            
            const statusDiv = document.getElementById('trainStatus');
            statusDiv.innerHTML = '<div class="status success">‚úì Eliminado</div>';
            setTimeout(() => { statusDiv.innerHTML = ''; }, 2000);
            
            updateStats();
            viewTraining();
        }

        function askAI() {
            const userInput = document.getElementById('userQuestion').value.trim();
            const responseDiv = document.getElementById('aiResponse');
            const analysisDiv = document.getElementById('analysis');
            const feedbackDiv = document.getElementById('feedbackSection');

            if (!userInput) {
                responseDiv.innerHTML = '<div class="status error">Escribe algo</div>';
                return;
            }

            questionCount++;
            saveToStorage();

            if (trainingData.length === 0) {
                responseDiv.innerHTML = '<div class="status info">‚ö†Ô∏è Entrena la IA primero</div>';
                return;
            }

            const correctedInput = fullCorrection(userInput);
            const finalInput = correctedInput.text;

            const matches = findMatches(finalInput);

            if (matches.length === 0 || matches[0].score < 10) {
                responseDiv.innerHTML = '<div class="status info">ü§î Sin coincidencias. Entrena m√°s.</div>';
                analysisDiv.innerHTML = '';
                feedbackDiv.innerHTML = '';
                lastUsedSources = [];
                
                conversationContext.push(finalInput);
                if (conversationContext.length > 5) conversationContext.shift();
            } else {
                const result = generateCombinedResponse(finalInput, matches);
                
                if (!result) {
                    responseDiv.innerHTML = '<div class="status info">ü§î No puedo generar respuesta confiable.</div>';
                    return;
                }
                
                lastUsedSources = result.sources.map(s => s.index);
                
                let html = `
                    <div style="color: #155724;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap;">
                            <strong style="font-size: 1.1em;">ü§ñ Respuesta IA:</strong>
                            <div>
                                <span class="match-score">${result.confidence.toFixed(0)}% confianza</span>
                                ${result.combined ? '<span class="combined-badge">üîÄ COMBINADA</span>' : ''}
                                <span class="coherence-badge">üìù ${result.coherence.toFixed(0)}% coherencia</span>
                            </div>
                        </div>
                        <div class="generated-response">
                            ${result.response}
                        </div>
                `;
                
                if (result.sources.length > 0) {
                    html += '<div class="source-list"><strong>üìö Fuentes:</strong>';
                    result.sources.forEach((source, idx) => {
                        html += `
                            <div class="source-item">
                                <span class="source-weight">#${idx + 1} ${source.weight.toFixed(0)}pts</span>
                                "${source.item.question}"
                            </div>
                        `;
                    });
                    html += '</div>';
                }
                
                html += '</div>';
                responseDiv.innerHTML = html;
                
                feedbackDiv.innerHTML = `
                    <div class="feedback-btns">
                        <button class="feedback-btn feedback-good" onclick="giveFeedback(true)">
                            üëç √ötil
                        </button>
                        <button class="feedback-btn feedback-bad" onclick="giveFeedback(false)">
                            üëé Incorrecta
                        </button>
                    </div>
                `;
                
                let analysisHTML = '<div class="analysis">';
                analysisHTML += '<strong>üîç An√°lisis Vocal Avanzado:</strong><br>';
                analysisHTML += `<div class="analysis-item">‚Ä¢ ${matches.length} fuentes analizadas</div>`;
                analysisHTML += `<div class="analysis-item">‚Ä¢ ${result.sources.length} fuentes combinadas</div>`;
                analysisHTML += `<div class="analysis-item">‚Ä¢ Coherencia: ${result.coherence.toFixed(0)}%</div>`;
                analysisHTML += `<div class="analysis-item">‚Ä¢ An√°lisis vocal aplicado</div>`;
                
                if (correctedInput.corrections.length > 0) {
                    analysisHTML += `<div class="analysis-item">‚Ä¢ Tu pregunta fue corregida autom√°ticamente</div>`;
                }
                
                analysisHTML += '</div>';
                analysisDiv.innerHTML = analysisHTML;
                
                conversationContext.push(finalInput);
                if (conversationContext.length > 5) conversationContext.shift();
            }

            updateStats();
        }

        function giveFeedback(isPositive) {
            if (lastUsedSources.length === 0) return;
            
            lastUsedSources.forEach(idx => {
                if (trainingData[idx]) {
                    trainingData[idx].useCount++;
                    if (isPositive) {
                        trainingData[idx].successCount++;
                    } else {
                        trainingData[idx].failCount++;
                    }
                }
            });
            
            saveToStorage();
            
            document.getElementById('feedbackSection').innerHTML = `
                <div class="status success">
                    ${isPositive ? '‚úì ¬°Gracias! IA mejorada' : '‚úì Registrado, ajustando pesos'}
                </div>
            `;
            updateStats();
            viewTraining();
        }

        function downloadTraining() {
            const statusDiv = document.getElementById('trainStatus');
            
            if (trainingData.length === 0) {
                statusDiv.innerHTML = '<div class="status error">Sin datos</div>';
                return;
            }

            const dataToExport = {
                version: '3.1',
                exportDate: new Date().toISOString(),
                trainingData: trainingData,
                questionCount: questionCount,
            };

            const dataStr = JSON.stringify(dataToExport, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = `ia-ultra-vocal-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            URL.revokeObjectURL(url);

            statusDiv.innerHTML = '<div class="status success">‚úì Descargado</div>';
            setTimeout(() => { statusDiv.innerHTML = ''; }, 3000);
        }

        function loadTraining(event) {
            const file = event.target.files[0];
            const statusDiv = document.getElementById('trainStatus');
            
            if (!file) return;

            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    if (!importedData.trainingData) {
                        throw new Error('Formato inv√°lido');
                    }

                    const loadedCount = importedData.trainingData.length;
                    
                    if (trainingData.length > 0) {
                        if (confirm(`Tienes ${trainingData.length}.\n\nOK=Reemplazar\nCancel=Agregar`)) {
                            trainingData = importedData.trainingData;
                        } else {
                            trainingData = [...trainingData, ...importedData.trainingData];
                        }
                    } else {
                        trainingData = importedData.trainingData;
                    }
                    
                    if (importedData.questionCount) {
                        questionCount = importedData.questionCount;
                    }
                    
                    saveToStorage();
                    
                    statusDiv.innerHTML = `<div class="status success">‚úì ${loadedCount} cargados</div>`;
                    updateStats();
                    viewTraining();
                    
                    setTimeout(() => { statusDiv.innerHTML = ''; }, 3000);
                    
                } catch (error) {
                    statusDiv.innerHTML = `<div class="status error">Error: ${error.message}</div>`;
                }
            };
            
            reader.readAsText(file);
            event.target.value = '';
        }

        function calculateTotalWords() {
            const allWords = new Set();
            trainingData.forEach(item => {
                item.questionWords.forEach(w => allWords.add(w));
                item.answerWords.forEach(w => allWords.add(w));
            });
            return allWords.size;
        }

        function viewTraining() {
            const listDiv = document.getElementById('trainingList');
            
            if (trainingData.length === 0) {
                listDiv.innerHTML = '<div class="status info">Sin entrenamiento</div>';
                return;
            }

            const sortedData = [...trainingData].sort((a, b) => {
                const rateA = a.successCount / (a.successCount + a.failCount || 1);
                const rateB = b.successCount / (b.successCount + b.failCount || 1);
                return rateB - rateA;
            });

            listDiv.innerHTML = sortedData.map(item => {
                const successRate = item.successCount / (item.successCount + item.failCount || 1);
                const rateColor = successRate > 0.7 ? '#4caf50' : successRate > 0.4 ? '#ff9800' : '#f44336';
                
                return `
                    <div class="training-item">
                        <div class="training-content">
                            <strong>Entrada:</strong> ${item.question}<br>
                            <strong>Salida:</strong> ${item.answer}<br>
                            <div style="margin-top: 8px; color: #666; font-size: 0.9em;">
                                <strong>Keywords:</strong> ${item.keywords.slice(0, 6).join(', ')}${item.keywords.length > 6 ? '...' : ''}
                            </div>
                            <div style="margin-top: 8px; display: flex; gap: 15px; font-size: 0.85em; flex-wrap: wrap;">
                                <span><strong>Usos:</strong> ${item.useCount}</span>
                                <span><strong>‚úì:</strong> ${item.successCount}</span>
                                <span><strong>‚úó:</strong> ${item.failCount}</span>
                                <span style="color: ${rateColor};"><strong>Tasa:</strong> ${(successRate * 100).toFixed(0)}%</span>
                            </div>
                        </div>
                        <button class="btn-delete" onclick="deleteTraining('${item.id}')">üóëÔ∏è</button>
                    </div>
                `;
            }).join('');
        }

        function clearAllTraining() {
            if (!confirm('¬øBORRAR TODO?')) return;

            trainingData = [];
            questionCount = 0;
            conversationContext = [];
            lastUsedSources = [];
            
            saveToStorage();
            
            document.getElementById('trainStatus').innerHTML = '<div class="status success">‚úì Limpio</div>';
            updateStats();
            viewTraining();
        }

        function updateStats() {
            document.getElementById('totalTraining').textContent = trainingData.length;
            document.getElementById('totalQuestions').textContent = questionCount;
            document.getElementById('totalWords').textContent = calculateTotalWords();
            
            const size = new Blob([JSON.stringify(trainingData)]).size;
            document.getElementById('dbSize').textContent = (size / 1024).toFixed(2) + ' KB';
        }

        function updateAutoTags() {
            const question = document.getElementById('question').value.trim();
            const answer = document.getElementById('answer').value.trim();
            
            if (!question && !answer) {
                document.getElementById('autoTags').style.display = 'none';
                return;
            }
            
            const keywords = extractKeywords(question + ' ' + answer);
            const uniqueKeywords = [...new Set(keywords)];
            
            if (uniqueKeywords.length > 0) {
                document.getElementById('tagsList').innerHTML = uniqueKeywords.slice(0, 8).map(tag => 
                    `<span>${tag}</span>`
                ).join('') + (uniqueKeywords.length > 8 ? '<span>+</span>' : '');
                document.getElementById('autoTags').style.display = 'block';
            } else {
                document.getElementById('autoTags').style.display = 'none';
            }
        }

        document.getElementById('question').addEventListener('input', updateAutoTags);
        document.getElementById('answer').addEventListener('input', updateAutoTags);

        window.addEventListener('load', () => {
            loadFromStorage();
            updateStats();
            viewTraining();
        });
    </script>
</body>
</html>